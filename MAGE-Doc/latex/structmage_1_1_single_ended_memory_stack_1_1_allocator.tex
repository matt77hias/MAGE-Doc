\hypertarget{structmage_1_1_single_ended_memory_stack_1_1_allocator}{}\section{mage\+:\+:Single\+Ended\+Memory\+Stack\+:\+:Allocator$<$ DataT $>$ Struct Template Reference}
\label{structmage_1_1_single_ended_memory_stack_1_1_allocator}\index{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator$<$ Data\+T $>$@{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator$<$ Data\+T $>$}}


{\ttfamily \#include $<$memory\+\_\+stack.\+hpp$>$}

\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
using \hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator_a4d5b98a534ad4e6d6f2d8eb1280398ab}{value\+\_\+type} = DataT
\item 
using \hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator_a408c0a4b29dc60e9564245c6a0a6fd4c}{propagate\+\_\+on\+\_\+container\+\_\+move\+\_\+assignment} = std\+::true\+\_\+type
\item 
using \hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator_a64d005be12e9d1749c0e6eeea5107a98}{is\+\_\+always\+\_\+equal} = std\+::false\+\_\+type
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator_acc7f17e870881240ee354efe69f9ba34}{Allocator} (const \hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator}{Allocator} \&allocator) noexcept=default
\item 
\hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator_a445eaee8e10d872886de2f4194ecca72}{Allocator} (\hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator}{Allocator} \&\&allocator) noexcept=default
\item 
{\footnotesize template$<$typename DataU $>$ }\\\hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator_ac0dc5bf3c1c3293cf081e45ed28101dc}{Allocator} (const \hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator}{Allocator}$<$ DataU $>$ \&allocator) noexcept
\item 
\hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator_a5b9721b0fb81964988f9f121d6372970}{$\sim$\+Allocator} ()=default
\item 
\hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator}{Allocator} \& \hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator_a22dbfaa5a0125fea5fdca730f07dac2c}{operator=} (const \hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator}{Allocator} \&allocator)=delete
\item 
\hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator}{Allocator} \& \hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator_a43cdcfdfe7ee8d8f82f542245c6fc1d5}{operator=} (\hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator}{Allocator} \&\&allocator) noexcept=default
\item 
DataT $\ast$ \hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator_a076727a4db2bd233d80ccbc5f01b84e5}{allocate} (size\+\_\+t count) const
\item 
DataT $\ast$ \hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator_abf93dd5bfcbda5c6d11703d212c89a76}{allocate} (size\+\_\+t count, \mbox{[}\mbox{[}maybe\+\_\+unused\mbox{]}\mbox{]} const void $\ast$hint) const
\item 
void \hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator_ae504db80c12f1b8aa0a4ebccae22b7b1}{deallocate} (\mbox{[}\mbox{[}maybe\+\_\+unused\mbox{]}\mbox{]} DataT $\ast$data, \mbox{[}\mbox{[}maybe\+\_\+unused\mbox{]}\mbox{]} size\+\_\+t count) const noexcept
\item 
{\footnotesize template$<$typename DataU $>$ }\\bool \hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator_a47f5e7baf66ddebc8aec402c6a9f1eef}{operator==} (const \hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator}{Allocator}$<$ DataU $>$ \&rhs) const noexcept
\item 
{\footnotesize template$<$typename DataU $>$ }\\bool \hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator_ae8b77280f1f31e30cb1536f8ecae08c9}{operator!=} (const \hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator}{Allocator}$<$ DataU $>$ \&rhs) const noexcept
\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator_a991173b1fccf74994dc9298b3cffb795}{Allocator} (\hyperlink{classmage_1_1_single_ended_memory_stack}{Single\+Ended\+Memory\+Stack} $\ast$memory\+\_\+stack) noexcept
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classmage_1_1_single_ended_memory_stack}{Single\+Ended\+Memory\+Stack} $\ast$ \hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator_ac5d79f87385234430d25cdf004255d70}{m\+\_\+memory\+\_\+stack}
\end{DoxyCompactItemize}
\subsection*{Friends}
\begin{DoxyCompactItemize}
\item 
class \hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator_a3f3449e5c2caa1666a293b36db6f5a54}{Single\+Ended\+Memory\+Stack}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$typename DataT$>$\newline
struct mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator$<$ Data\+T $>$}

A struct of allocators for single-\/ended memory stacks.


\begin{DoxyTemplParams}{Template Parameters}
{\em DataT} & The data type. \\
\hline
\end{DoxyTemplParams}


\subsection{Member Typedef Documentation}
\hypertarget{structmage_1_1_single_ended_memory_stack_1_1_allocator_a64d005be12e9d1749c0e6eeea5107a98}{}\label{structmage_1_1_single_ended_memory_stack_1_1_allocator_a64d005be12e9d1749c0e6eeea5107a98} 
\index{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator@{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator}!is\+\_\+always\+\_\+equal@{is\+\_\+always\+\_\+equal}}
\index{is\+\_\+always\+\_\+equal@{is\+\_\+always\+\_\+equal}!mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator@{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator}}
\subsubsection{\texorpdfstring{is\+\_\+always\+\_\+equal}{is\_always\_equal}}
{\footnotesize\ttfamily template$<$typename DataT $>$ \\
using \hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator}{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator}$<$ DataT $>$\+::\hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator_a64d005be12e9d1749c0e6eeea5107a98}{is\+\_\+always\+\_\+equal} =  std\+::false\+\_\+type}

\hypertarget{structmage_1_1_single_ended_memory_stack_1_1_allocator_a408c0a4b29dc60e9564245c6a0a6fd4c}{}\label{structmage_1_1_single_ended_memory_stack_1_1_allocator_a408c0a4b29dc60e9564245c6a0a6fd4c} 
\index{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator@{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator}!propagate\+\_\+on\+\_\+container\+\_\+move\+\_\+assignment@{propagate\+\_\+on\+\_\+container\+\_\+move\+\_\+assignment}}
\index{propagate\+\_\+on\+\_\+container\+\_\+move\+\_\+assignment@{propagate\+\_\+on\+\_\+container\+\_\+move\+\_\+assignment}!mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator@{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator}}
\subsubsection{\texorpdfstring{propagate\+\_\+on\+\_\+container\+\_\+move\+\_\+assignment}{propagate\_on\_container\_move\_assignment}}
{\footnotesize\ttfamily template$<$typename DataT $>$ \\
using \hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator}{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator}$<$ DataT $>$\+::\hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator_a408c0a4b29dc60e9564245c6a0a6fd4c}{propagate\+\_\+on\+\_\+container\+\_\+move\+\_\+assignment} =  std\+::true\+\_\+type}

\hypertarget{structmage_1_1_single_ended_memory_stack_1_1_allocator_a4d5b98a534ad4e6d6f2d8eb1280398ab}{}\label{structmage_1_1_single_ended_memory_stack_1_1_allocator_a4d5b98a534ad4e6d6f2d8eb1280398ab} 
\index{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator@{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator}!value\+\_\+type@{value\+\_\+type}}
\index{value\+\_\+type@{value\+\_\+type}!mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator@{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator}}
\subsubsection{\texorpdfstring{value\+\_\+type}{value\_type}}
{\footnotesize\ttfamily template$<$typename DataT $>$ \\
using \hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator}{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator}$<$ DataT $>$\+::\hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator_a4d5b98a534ad4e6d6f2d8eb1280398ab}{value\+\_\+type} =  DataT}

The element type of allocators. 

\subsection{Constructor \& Destructor Documentation}
\hypertarget{structmage_1_1_single_ended_memory_stack_1_1_allocator_acc7f17e870881240ee354efe69f9ba34}{}\label{structmage_1_1_single_ended_memory_stack_1_1_allocator_acc7f17e870881240ee354efe69f9ba34} 
\index{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator@{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator}!Allocator@{Allocator}}
\index{Allocator@{Allocator}!mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator@{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator}}
\subsubsection{\texorpdfstring{Allocator()}{Allocator()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily template$<$typename DataT $>$ \\
\hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator}{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator}$<$ DataT $>$\+::\hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator}{Allocator} (\begin{DoxyParamCaption}\item[{const \hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator}{Allocator}$<$ DataT $>$ \&}]{allocator }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [default]}, {\ttfamily [noexcept]}}

Constructs an allocator from the given allocator.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em allocator} & A reference to the allocator to copy. \\
\hline
\end{DoxyParams}
\hypertarget{structmage_1_1_single_ended_memory_stack_1_1_allocator_a445eaee8e10d872886de2f4194ecca72}{}\label{structmage_1_1_single_ended_memory_stack_1_1_allocator_a445eaee8e10d872886de2f4194ecca72} 
\index{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator@{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator}!Allocator@{Allocator}}
\index{Allocator@{Allocator}!mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator@{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator}}
\subsubsection{\texorpdfstring{Allocator()}{Allocator()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily template$<$typename DataT $>$ \\
\hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator}{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator}$<$ DataT $>$\+::\hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator}{Allocator} (\begin{DoxyParamCaption}\item[{\hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator}{Allocator}$<$ DataT $>$ \&\&}]{allocator }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [default]}, {\ttfamily [noexcept]}}

Constructs an allocator by moving the given allocator.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em allocator} & A reference to the allocator to move. \\
\hline
\end{DoxyParams}
\hypertarget{structmage_1_1_single_ended_memory_stack_1_1_allocator_ac0dc5bf3c1c3293cf081e45ed28101dc}{}\label{structmage_1_1_single_ended_memory_stack_1_1_allocator_ac0dc5bf3c1c3293cf081e45ed28101dc} 
\index{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator@{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator}!Allocator@{Allocator}}
\index{Allocator@{Allocator}!mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator@{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator}}
\subsubsection{\texorpdfstring{Allocator()}{Allocator()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily template$<$typename DataT $>$ \\
template$<$typename DataU $>$ \\
\hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator}{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator}$<$ DataT $>$\+::\hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator}{Allocator} (\begin{DoxyParamCaption}\item[{const \hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator}{Allocator}$<$ DataU $>$ \&}]{allocator }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [noexcept]}}

Constructs an allocator from the given allocator.


\begin{DoxyTemplParams}{Template Parameters}
{\em DataU} & The data type. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em allocator} & A reference to the allocator to copy. \\
\hline
\end{DoxyParams}
\hypertarget{structmage_1_1_single_ended_memory_stack_1_1_allocator_a5b9721b0fb81964988f9f121d6372970}{}\label{structmage_1_1_single_ended_memory_stack_1_1_allocator_a5b9721b0fb81964988f9f121d6372970} 
\index{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator@{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator}!````~Allocator@{$\sim$\+Allocator}}
\index{````~Allocator@{$\sim$\+Allocator}!mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator@{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator}}
\subsubsection{\texorpdfstring{$\sim$\+Allocator()}{~Allocator()}}
{\footnotesize\ttfamily template$<$typename DataT $>$ \\
\hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator}{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator}$<$ DataT $>$\+::$\sim$\hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator}{Allocator} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [default]}}

Destructs this allocator. \hypertarget{structmage_1_1_single_ended_memory_stack_1_1_allocator_a991173b1fccf74994dc9298b3cffb795}{}\label{structmage_1_1_single_ended_memory_stack_1_1_allocator_a991173b1fccf74994dc9298b3cffb795} 
\index{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator@{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator}!Allocator@{Allocator}}
\index{Allocator@{Allocator}!mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator@{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator}}
\subsubsection{\texorpdfstring{Allocator()}{Allocator()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily template$<$typename DataT $>$ \\
\hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator}{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator}$<$ DataT $>$\+::\hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator}{Allocator} (\begin{DoxyParamCaption}\item[{\hyperlink{classmage_1_1_single_ended_memory_stack}{Single\+Ended\+Memory\+Stack} $\ast$}]{memory\+\_\+stack }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [explicit]}, {\ttfamily [private]}, {\ttfamily [noexcept]}}

Constructs an allocator.

\begin{DoxyPrecond}{Precondition}
{\itshape memory\+\_\+stack} is not equal to {\ttfamily nullptr}. 
\end{DoxyPrecond}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em memory\+\_\+stack} & A pointer to the memory stack. \\
\hline
\end{DoxyParams}


\subsection{Member Function Documentation}
\hypertarget{structmage_1_1_single_ended_memory_stack_1_1_allocator_a076727a4db2bd233d80ccbc5f01b84e5}{}\label{structmage_1_1_single_ended_memory_stack_1_1_allocator_a076727a4db2bd233d80ccbc5f01b84e5} 
\index{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator@{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator}!allocate@{allocate}}
\index{allocate@{allocate}!mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator@{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator}}
\subsubsection{\texorpdfstring{allocate()}{allocate()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DataT $>$ \\
DataT$\ast$ \hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator}{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator}$<$ DataT $>$\+::allocate (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{count }\end{DoxyParamCaption}) const}

Attempts to allocate a block of storage with a size large enough to contain {\itshape count} elements of type {\ttfamily DataT}, and returns a pointer to the first element.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em count} & The number of element objects of type {\ttfamily DataT} to allocate in memory. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A pointer to the memory block that was allocated. 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::bad\+\_\+alloc} & Failed to allocate the memory block. \\
\hline
\end{DoxyExceptions}
\hypertarget{structmage_1_1_single_ended_memory_stack_1_1_allocator_abf93dd5bfcbda5c6d11703d212c89a76}{}\label{structmage_1_1_single_ended_memory_stack_1_1_allocator_abf93dd5bfcbda5c6d11703d212c89a76} 
\index{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator@{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator}!allocate@{allocate}}
\index{allocate@{allocate}!mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator@{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator}}
\subsubsection{\texorpdfstring{allocate()}{allocate()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DataT $>$ \\
DataT$\ast$ \hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator}{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator}$<$ DataT $>$\+::allocate (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{count,  }\item[{\mbox{[}\mbox{[}maybe\+\_\+unused\mbox{]} \mbox{]} const void $\ast$}]{hint }\end{DoxyParamCaption}) const}

Attempts to allocate a block of storage with a size large enough to contain {\itshape count} elements of type {\ttfamily DataT}, and returns a pointer to the first element.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em count} & The number of element objects of type {\ttfamily DataT} to allocate in memory. \\
\hline
\mbox{\tt in}  & {\em hint} & Either {\ttfamily nullptr} or a value previously obtained by another call to \hyperlink{}{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator$<$\+Data\+T$>$\+::allocate(size\+\_\+t)} or \hyperlink{}{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator$<$\+Data\+T$>$\+::allocate$<$\+Data\+U$>$(size\+\_\+t, const Data\+U$\ast$)} and not yet freed with \hyperlink{}{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator$<$\+Data\+T$>$\+::deallocate(\+Data\+T$\ast$, size\+\_\+t)}. When not equal to {\ttfamily nullptr}, this value may be used as a hint to improve performance by allocating the new block near the one specified. The address of an adjacent element is often a good choice. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A pointer to the memory block that was allocated. 
\end{DoxyReturn}

\begin{DoxyExceptions}{Exceptions}
{\em std\+::bad\+\_\+alloc} & Failed to allocate the memory block. \\
\hline
\end{DoxyExceptions}
\hypertarget{structmage_1_1_single_ended_memory_stack_1_1_allocator_ae504db80c12f1b8aa0a4ebccae22b7b1}{}\label{structmage_1_1_single_ended_memory_stack_1_1_allocator_ae504db80c12f1b8aa0a4ebccae22b7b1} 
\index{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator@{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator}!deallocate@{deallocate}}
\index{deallocate@{deallocate}!mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator@{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator}}
\subsubsection{\texorpdfstring{deallocate()}{deallocate()}}
{\footnotesize\ttfamily template$<$typename DataT $>$ \\
void \hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator}{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator}$<$ DataT $>$\+::deallocate (\begin{DoxyParamCaption}\item[{\mbox{[}\mbox{[}maybe\+\_\+unused\mbox{]} \mbox{]} DataT $\ast$}]{data,  }\item[{\mbox{[}\mbox{[}maybe\+\_\+unused\mbox{]} \mbox{]} size\+\_\+t}]{count }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [noexcept]}}

Releases a block of storage previously allocated with \hyperlink{}{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator$<$\+Data\+T$>$\+::allocate(size\+\_\+t)} or \hyperlink{}{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator$<$\+Data\+T$>$\+::allocate$<$\+Data\+U$>$(size\+\_\+t, const Data\+U$\ast$)} and not yet released.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em data} & A pointer to the memory block that needs to be released. \\
\hline
\mbox{\tt in}  & {\em count} & The number of element objects allocated on the call to allocate for this block of storage. \\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
The elements in the array are not destroyed. 
\end{DoxyNote}
\hypertarget{structmage_1_1_single_ended_memory_stack_1_1_allocator_ae8b77280f1f31e30cb1536f8ecae08c9}{}\label{structmage_1_1_single_ended_memory_stack_1_1_allocator_ae8b77280f1f31e30cb1536f8ecae08c9} 
\index{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator@{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator@{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator}}
\subsubsection{\texorpdfstring{operator"!=()}{operator!=()}}
{\footnotesize\ttfamily template$<$typename DataT $>$ \\
template$<$typename DataU $>$ \\
bool \hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator}{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator}$<$ DataT $>$\+::operator!= (\begin{DoxyParamCaption}\item[{const \hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator}{Allocator}$<$ DataU $>$ \&}]{rhs }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [noexcept]}}

Compares this allocator to the given allocator for non-\/equality.


\begin{DoxyTemplParams}{Template Parameters}
{\em DataU} & The data type. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em rhs} & A reference to the allocator to compare with. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily true} if and only if storage allocated from this allocator cannot be deallocated from the given allocator, and vice versa. {\ttfamily false} otherwise. 
\end{DoxyReturn}
\hypertarget{structmage_1_1_single_ended_memory_stack_1_1_allocator_a22dbfaa5a0125fea5fdca730f07dac2c}{}\label{structmage_1_1_single_ended_memory_stack_1_1_allocator_a22dbfaa5a0125fea5fdca730f07dac2c} 
\index{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator@{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator}!operator=@{operator=}}
\index{operator=@{operator=}!mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator@{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator}}
\subsubsection{\texorpdfstring{operator=()}{operator=()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename DataT $>$ \\
\hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator}{Allocator}\& \hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator}{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator}$<$ DataT $>$\+::operator= (\begin{DoxyParamCaption}\item[{const \hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator}{Allocator}$<$ DataT $>$ \&}]{allocator }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [delete]}}

Copies the given allocator to this allocator.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em allocator} & A reference to the allocator to copy. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A reference to the copy of the given allocator (i.\+e. this allocator). 
\end{DoxyReturn}
\hypertarget{structmage_1_1_single_ended_memory_stack_1_1_allocator_a43cdcfdfe7ee8d8f82f542245c6fc1d5}{}\label{structmage_1_1_single_ended_memory_stack_1_1_allocator_a43cdcfdfe7ee8d8f82f542245c6fc1d5} 
\index{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator@{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator}!operator=@{operator=}}
\index{operator=@{operator=}!mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator@{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator}}
\subsubsection{\texorpdfstring{operator=()}{operator=()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename DataT $>$ \\
\hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator}{Allocator}\& \hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator}{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator}$<$ DataT $>$\+::operator= (\begin{DoxyParamCaption}\item[{\hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator}{Allocator}$<$ DataT $>$ \&\&}]{allocator }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [default]}, {\ttfamily [noexcept]}}

Moves the given allocator to this allocator.


\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em allocator} & A reference to the allocator to move. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
A reference to the moved allocator (i.\+e. this allocator). 
\end{DoxyReturn}
\hypertarget{structmage_1_1_single_ended_memory_stack_1_1_allocator_a47f5e7baf66ddebc8aec402c6a9f1eef}{}\label{structmage_1_1_single_ended_memory_stack_1_1_allocator_a47f5e7baf66ddebc8aec402c6a9f1eef} 
\index{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator@{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator}!operator==@{operator==}}
\index{operator==@{operator==}!mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator@{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator}}
\subsubsection{\texorpdfstring{operator==()}{operator==()}}
{\footnotesize\ttfamily template$<$typename DataT $>$ \\
template$<$typename DataU $>$ \\
bool \hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator}{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator}$<$ DataT $>$\+::operator== (\begin{DoxyParamCaption}\item[{const \hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator}{Allocator}$<$ DataU $>$ \&}]{rhs }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [noexcept]}}

Compares this allocator to the given allocator for equality.


\begin{DoxyTemplParams}{Template Parameters}
{\em DataU} & The data type. \\
\hline
\end{DoxyTemplParams}

\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em rhs} & A reference to the allocator to compare with. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
{\ttfamily true} if and only if storage allocated from this allocator can be deallocated from the given allocator, and vice versa. {\ttfamily false} otherwise. 
\end{DoxyReturn}


\subsection{Friends And Related Function Documentation}
\hypertarget{structmage_1_1_single_ended_memory_stack_1_1_allocator_a3f3449e5c2caa1666a293b36db6f5a54}{}\label{structmage_1_1_single_ended_memory_stack_1_1_allocator_a3f3449e5c2caa1666a293b36db6f5a54} 
\index{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator@{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator}!Single\+Ended\+Memory\+Stack@{Single\+Ended\+Memory\+Stack}}
\index{Single\+Ended\+Memory\+Stack@{Single\+Ended\+Memory\+Stack}!mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator@{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator}}
\subsubsection{\texorpdfstring{Single\+Ended\+Memory\+Stack}{SingleEndedMemoryStack}}
{\footnotesize\ttfamily template$<$typename DataT $>$ \\
friend class \hyperlink{classmage_1_1_single_ended_memory_stack}{Single\+Ended\+Memory\+Stack}\hspace{0.3cm}{\ttfamily [friend]}}



\subsection{Member Data Documentation}
\hypertarget{structmage_1_1_single_ended_memory_stack_1_1_allocator_ac5d79f87385234430d25cdf004255d70}{}\label{structmage_1_1_single_ended_memory_stack_1_1_allocator_ac5d79f87385234430d25cdf004255d70} 
\index{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator@{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator}!m\+\_\+memory\+\_\+stack@{m\+\_\+memory\+\_\+stack}}
\index{m\+\_\+memory\+\_\+stack@{m\+\_\+memory\+\_\+stack}!mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator@{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator}}
\subsubsection{\texorpdfstring{m\+\_\+memory\+\_\+stack}{m\_memory\_stack}}
{\footnotesize\ttfamily template$<$typename DataT $>$ \\
\hyperlink{classmage_1_1_single_ended_memory_stack}{Single\+Ended\+Memory\+Stack}$\ast$ \hyperlink{structmage_1_1_single_ended_memory_stack_1_1_allocator}{mage\+::\+Single\+Ended\+Memory\+Stack\+::\+Allocator}$<$ DataT $>$\+::m\+\_\+memory\+\_\+stack\hspace{0.3cm}{\ttfamily [private]}}

A pointer to the memory stack of this allocator. 